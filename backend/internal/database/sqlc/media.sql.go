// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteMediaByID = `-- name: DeleteMediaByID :exec
DELETE FROM media
WHERE id = $1
`

func (q *Queries) DeleteMediaByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMediaByID, id)
	return err
}

const getMediaByFilename = `-- name: GetMediaByFilename :one
SELECT id, filename, path, mime_type, size_bytes, uploader_id, created_at, updated_at
FROM media
WHERE filename = $1
LIMIT 1
`

func (q *Queries) GetMediaByFilename(ctx context.Context, filename string) (Medium, error) {
	row := q.db.QueryRow(ctx, getMediaByFilename, filename)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Path,
		&i.MimeType,
		&i.SizeBytes,
		&i.UploaderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMedia = `-- name: InsertMedia :one
INSERT INTO media (
  filename, path, mime_type, size_bytes, uploader_id
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, filename, path, mime_type, size_bytes, uploader_id, created_at, updated_at
`

type InsertMediaParams struct {
	Filename   string      `json:"filename"`
	Path       string      `json:"path"`
	MimeType   string      `json:"mime_type"`
	SizeBytes  int64       `json:"size_bytes"`
	UploaderID pgtype.UUID `json:"uploader_id"`
}

func (q *Queries) InsertMedia(ctx context.Context, arg InsertMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, insertMedia,
		arg.Filename,
		arg.Path,
		arg.MimeType,
		arg.SizeBytes,
		arg.UploaderID,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Path,
		&i.MimeType,
		&i.SizeBytes,
		&i.UploaderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMediaAll = `-- name: ListMediaAll :many
SELECT id, filename, path, mime_type, size_bytes, uploader_id, created_at, updated_at
FROM media
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListMediaAllParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMediaAll(ctx context.Context, arg ListMediaAllParams) ([]Medium, error) {
	rows, err := q.db.Query(ctx, listMediaAll, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Path,
			&i.MimeType,
			&i.SizeBytes,
			&i.UploaderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaByUploader = `-- name: ListMediaByUploader :many
SELECT id, filename, path, mime_type, size_bytes, uploader_id, created_at, updated_at
FROM media
WHERE uploader_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMediaByUploaderParams struct {
	UploaderID pgtype.UUID `json:"uploader_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListMediaByUploader(ctx context.Context, arg ListMediaByUploaderParams) ([]Medium, error) {
	rows, err := q.db.Query(ctx, listMediaByUploader, arg.UploaderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Path,
			&i.MimeType,
			&i.SizeBytes,
			&i.UploaderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMedia = `-- name: UpdateMedia :one
UPDATE media
SET mime_type = $2, size_bytes = $3, path = $4
WHERE id = $1
RETURNING id, filename, path, mime_type, size_bytes, uploader_id, created_at, updated_at
`

type UpdateMediaParams struct {
	ID        pgtype.UUID `json:"id"`
	MimeType  string      `json:"mime_type"`
	SizeBytes int64       `json:"size_bytes"`
	Path      string      `json:"path"`
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, updateMedia,
		arg.ID,
		arg.MimeType,
		arg.SizeBytes,
		arg.Path,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Path,
		&i.MimeType,
		&i.SizeBytes,
		&i.UploaderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
